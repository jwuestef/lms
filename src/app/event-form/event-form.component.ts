import { Component, Output, EventEmitter } from '@angular/core';
import { NgModel } from '@angular/forms';
import { AngularFireDatabase } from 'angularfire2/database';
import { FlashMessagesService } from 'angular2-flash-messages';

import { EventService } from '../services/event.service';


@Component({
  selector: 'app-event-form',
  templateUrl: './event-form.component.html',
  styleUrls: ['./event-form.component.css']
})
export class EventFormComponent {
  @Output() clickSubmit = new EventEmitter<string>();
  eventName: string;
  eventDate: string;
  eventLink = '';
  eventType = 'Event Type';
  showEdit = false;
  currentForm = 'Add';
  operation = '';
  nameError = false;
  eventsListAsObject;



  // The contructor function runs automatically on component load, each and every time it's called
  constructor(private es: EventService, private afd: AngularFireDatabase, private fms: FlashMessagesService) { }



  addOrEditEvent(data) {
    const currentEvent = {
      id: '',
      title: this.eventName,
      start: this.eventDate,
      color: this.eventType,
      url: this.eventLink
    };
    // What is the current form Add or Edit?
    if (this.currentForm === 'Add') {
      // Save it to Firebase
      const thisSaved = this;
      // save currentEvent to database
      const dbRef = this.afd.database.ref('/calendars/' + this.es.currentCalender.title + '/events').push(currentEvent);
      // Assign object Id generated by db to object
      currentEvent.id = dbRef.key;
      this.es.eventArray.push(currentEvent);
      // Emit an event to call a the renderEvents function to render the new event on the calendar
      this.clickSubmit.emit('add');
    } else {
      // If the form is Edit
      // Set eventBeingEdited properties to the new values set by the user form
      this.es.eventBeingEdited.start._i = this.eventDate;
      this.es.eventBeingEdited.title = this.eventName;
      this.es.eventBeingEdited.url = this.eventLink;
      this.es.eventBeingEdited.color = this.eventType;
      // Emit an event to call the editEvents function to rerender that edited event
      this.clickSubmit.emit('');
      // Switch form back to add
      this.showEdit = false;
      this.currentForm = 'Add';
      // update the datebase with using the object currentEvent // Update the database with using the object currentEvent

      const thisSaved = this;
      // query database for all events on this calendar, return object full of eventObjects
      this.afd.database.ref('/calendars/' + this.es.currentCalender.title + '/events').once('value').then(function (eventsListFromDB) {
        thisSaved.eventsListAsObject = eventsListFromDB.val();
        // console.log('The returned object full of events (named "eventsListAsObject") is: ');
        // console.log(thisSaved.eventsListAsObject);
        // console.log('Now looping over object key/value pairs:');
        Object.keys(thisSaved.eventsListAsObject).forEach(function (key) {
          // console.log(key + ' <--key has value --> ' + thisSaved.eventsListAsObject[key]);
          // console.log(thisSaved.eventsListAsObject[key]);
          // console.log('This event\'s title from the DB is:');
          // console.log(thisSaved.eventsListAsObject[key]['title']);
          // console.log('This event\'s start from the DB is:');
          // console.log(thisSaved.eventsListAsObject[key]['start']);
          // When the key matches with the event update it
          if (thisSaved.es.eventBeingEdited.id === key) {
            thisSaved.afd.database.ref('/calendars/' + thisSaved.es.currentCalender.title + '/events/' + key).update({
              title: thisSaved.es.eventBeingEdited.title,
              start: thisSaved.es.eventBeingEdited.start._i,
              color: thisSaved.es.eventBeingEdited.color,
              url: thisSaved.es.eventBeingEdited.url
            }).then(function () {
              // Event was edited
              thisSaved.fms.show(
                '\'' + thisSaved.es.eventBeingEdited.title + '\' edited in ' + '\'' + thisSaved.es.currentCalender.title + '\'',
                {
                  cssClass: 'alert-success', // This is the pretty alert
                  timeout: 1500
                }
              );
            }).catch(function (err) {
              console.log('Error editing event!');
              console.log(err); // show errors
            });
          } else {
            // if the event key is not found
            console.log('Event key not found');
            console.log(thisSaved.es.eventBeingEdited.id);
            console.log(key);
          }
        });
      });


    }
    // Clears form fields
    this.eventDate = '';
    this.eventName = '';
    this.eventType = 'Event Type';
    this.eventLink = '';
  }


  // Populates the event form
  editEvent(data) {
    this.showEdit = true;
    this.currentForm = 'Edit';
    this.es.eventBeingEdited = data;
    this.eventDate = data.start._i;
    this.eventName = data.title;
    this.eventLink = data.url;
    this.eventType = data.color;

  }



  deleteEvent() {
    // Fires event to call the render event to delete the event from the calendar
    this.clickSubmit.emit('delete');
    // query database for all events on this calendar, return object full of eventObjects
    const thisSaved = this;
    this.afd.database.ref('/calendars/' + this.es.currentCalender.title + '/events').once('value').then(function (eventsListFromDB) {
      thisSaved.eventsListAsObject = eventsListFromDB.val();
      // console.log('Now looping over object key/value pairs:');
      Object.keys(thisSaved.eventsListAsObject).forEach(function (key) {
        if (thisSaved.es.eventBeingEdited.id === key) {
          // query db to remove the event if it was found
          thisSaved.afd.database.ref('/calendars/' + thisSaved.es.currentCalender.title + '/events/' + key).remove().then(function () {
            // console.log('Event removed!');
            thisSaved.fms.show(
              '\'' + thisSaved.es.eventBeingEdited.title + '\' removed from ' + '\'' + thisSaved.es.currentCalender.title + '\'',
              {
                cssClass: 'alert-success', // pretty alert that delete succeeded
                timeout: 1500
              }
            );
          }).catch(function (err) {
            console.log('Error deleting event!');
            console.log(err);
          });
        }
      });
    });

  }



  setAction(action) {
    this.operation = action;
  }
  chooseAction() {// Form Validation
    if (this.eventName === '' || this.eventName === undefined) { // check if eventName is empty
      this.nameError = true;
    } else {
      if (this.eventDate === undefined || this.eventDate === '') { // check if eventData is empty
        this.nameError = true;
      } else {
        if (this.operation === 'addOrEdit') {
          // perform either Add or Edit
          this.nameError = false;
          this.addOrEditEvent(this.currentForm);
        } else {
          // perform Delete
          this.nameError = false;
          this.deleteEvent();
        }
      }
    }
  }

  switchToAdd() { // switches to the add Form
    this.showEdit = false;
    this.currentForm = 'Add';
    this.eventDate = '';
    this.eventName = '';
    this.eventType = 'Event Type';
    this.eventLink = '';
  }



}  // End of component
